```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction to R

Welcome to the course! Over the next semester, we'll be doing 

## What is R? {-}
[R](https://en.wikipedia.org/wiki/R_(programming_language)) is a [programming language](https://en.wikipedia.org/wiki/Programming_language) used most commonly for data analysis and science. It's completely free and is adaptable to almost any project - for instance, this book, my website, and plenty of statistical softwares are all written in R.

Once you know how to code in R, learning about and implementing those different adaptations is a piece of cake. The purpose of this class is to get you up to speed with the coding!

## What is coding? {-}
Coding is giving very specific instructions to a very stupid machine.  
Or rather, a very _literal_ machine - if you do things out of order, or misspell something, or capitalize things you shouldn't, the computer won't do it - instead, it'll give you an error message. But if you get the syntax exactly right, the computer can do very complex tasks very quickly.

If that sounds frustrating, well... it sometimes is! But getting good at coding is mostly learning to be okay with being frustrated - and learning what to do when your code is being frustrated.

For this class, remember that you can always email me - <mike.mahoney.218@gmail.com> - or swing by office hours for help with your code. We'll go over strategies to fix your code outside of this class later on in the semester.


## Conventions of the course (and this reader) {-}
We'll go over standard code styles a bit later in the course - there is a Right Way**^tm^** to code, but we won't worry about that for a few more weeks. But so you can understand a few basics, here's a few styles we'll use in the text:

If text is ```preformatted```, it means it's something from R - a function, some data, or anything else that you'd use in your code. Blocks of code will be represented as follows:

```{r eval=FALSE}
print("Hello, World!")
```

This format both makes it obvious that this is code - not text - and lets you copy and paste it into your R session to see the results for yourself. Code outputs, meanwhile, will mostly be shown like this:

```{r echo=FALSE}
print("Hello, World!")
```

Where text is commented out (that is, has a # in front, so R won't parse it), so it won't do anything if you put it in your session.

There are some exceptions to these general rules, but this is enough to get us started. With the introductions out of the way, we can start getting you set up to coding R.

## Things You'll Need {-}
There are several pieces of software integral to this course reader, namely:

* R [download it here](https://cloud.r-project.org/)
* RStudio [download it here](https://www.rstudio.com/products/rstudio/download/#download)
  + Choose the free desktop version - you don't need the server software, and you don't need the commercial license.
* GitHub Desktop [download it here](https://desktop.github.com/)
  + You don't need this until later in the course - and if you're not actually enrolled in the course, you'll technically never need it. You'll be better off for knowing it, and it'll make your life better - but you can get away without it.
  
We'll be installing other pieces of software (in the form of R packages) throughout this reader, but each of those will be explicitly labeled when we use them. 

## Introduction to RStudio {-}
You'll almost never need to use R directly in this course - the form of R that you download from that first link is much harder to use than anything professionals interact with. Most practitioners use what's known as an IDE - an Interactive Development Environment. There's a lot of choices of IDEs for R, but RStudio is the best one.

Other textbooks would give you a more measured, even-handed approach to this issue. RStudio is the best one, though.

This course is assuming you're using RStudio for all the examples, questions, and assignments. As such, we're going to go over what you'll see when you open RStudio for the first time.

```{r echo=FALSE}
knitr::include_graphics("StudioOpening.png")
```

On the bottom right there you'll see a list of all the files available in the folder that you're working in. This window will also show you graphs when you make them, and help files when you look for them. Above it is a list of everything that's available in the current "environment" - that is, all the datasets/functions/code that you've already programmed in the session, that can be used again moving forward.

On the left - taking up the full height of the pane - is something called the "Console". This is the first place you can write R code, where you can give very specific commands to that very dumb machine. Try it now - it's time for us to start coding! 

## Your First Program
Type the following into the console:

```{r eval=FALSE}
print("Hello, world!")
```

What happened? If you did it right, you should have gotten the following:

```{r echo=FALSE}
print("Hello, world!")
```

It's cool, right? Congratulations, you're officially a programmer!

In addition to saying the things you tell it, you can use the R console to do math:

```{r}
2 + 4 / 2

6^7

18%%7
```

Note that R _generally_ follows PEMDAS - we'll go over that later.  
Also, ```%%``` is an operator (in the same way that ```+```, ```*```, ```-```, and ```/``` are all operators - mathematical symbols that represent a function) which returns the remainder - the integer (whole number) which remains after you've divided as much as you can. So while 7 fits into 18 twice (7*2 = 14), it leaves 4 "left over" afterwards.

R can also do a lot of more complicated things. By putting a list of values inside ```c()```, you create what's known as a _vector_ - a list of objects that R can interact with.

```{r}
c(1,2,3)

c(18, "ESF", 98)

c("ESF", "Acorns", "Stumpies")
```

Look at the difference between that first and that second output - see how the numbers are in quotes the second time around? While R is capable of holding a lot of different types of data, a single vector isn't. A vector has to either be a _numeric_ or a _character_ vector - it's either numbers or symbols. This matters, because you can't do math with symbols. For instance, if we try to divide the first vector by 3:

```{r}
c(1,2,3) / 3
```

It works just fine. But trying to divide our second vector:

```
c(18, "ESF", 98) / 3
```

```
Error in c(18, "ESF", 98)/3 : non-numeric argument to binary operator
```

Gives us our first error message of the course.

I should mention that I lied a little bit - vectors can also be a third type, _logical_. If a vector is made up of ```TRUE``` and ```FALSE``` elements - and no other elements - then the vector is considered logical.

Logical values are exactly what they sound like - they return ```TRUE``` if something is true, and ```FALSE``` if not. For instance:

```{r}
6 > 4

4 > 6
```

But again, vectors can only hold one type of data - a vector with a value of ```TRUE``` and a value of ```ESF``` will become a character vector.

If you need to hold more than one type of data, you need a table - or, as they're called in R, a dataframe. It is possible to make dataframes by hand in R:

```{r}
data.frame(x = c(1,2,3),
           y = c("a","b","c"),
           z = c(TRUE, TRUE, FALSE))
```

However, this is rare - most of the time, your data will be far too big to make inputting it in R make any sense. Instead, you'll have to import it from a file elsewhere on your computer - but we'll get to that later.


## The iris Dataset
What's very cool for our purposes is that R comes preloaded with a number of different datasets. Now, if you just type in the name of the dataset, you might overwhelm R for a moment - it will print out every single row of that dataset, no matter how long it is.  
Luckily for us, the ```head``` command lets us see just the first few rows of the data. If we use the dataset ```iris``` (included in base R), for instance, we'd get the following result:

```{r}
head(iris)
```

Note that while the default is to print six rows, you can choose how many rows to print by specifying ```n = ##``` in the ```head()``` function. You can even call the last few rows of your dataset by using the similar function ```tail``` - for instance:

```{r}
tail(iris, n=3)
```

Pretty neat!

This dataset contains measurements on 150 different irises, and is the data that was used to develop the first ever linear regressions. Even if you aren't a stats nerd, this dataset lets us do some cool things. For instance, we can see that there are columns containing information on sepal length and sepal width - I wonder if they might be correlated? What would happen if we asked R to ```plot``` them for us?

```{r}
plot(iris$Sepal.Length, iris$Sepal.Width)
```

Luckily, as you can see, R has some basic plotting functions built right in. However, these plots are hard to use - and to understand. It seems like sepal length and width are completely unrelated!

Thankfully enough, R has a ton of add-on softwares - called _packages_ - which dramatically expand R's usefullness. Let's install the most common ones now:

```
install.packages("tidyverse")
```
```{r}
library(tidyverse)
```

Note the quotes around "tidyverse" when you go to install it, but **not** when it's inside of ```library()```. 

What we just did was install a package called the ```tidyverse``` (with ```install.packages```), and load it using ```library```. A "package" is just R code created by someone else - most common problems in R have already been solved by someone else, and most of those people have made their work publicly available for others to use.

The tidyverse is a pretty unique example of a package - it actually contains six packages, most of which are essential to using R like a professional. The most important one we're going to use right now is called ```ggplot2```. Don't worry about having to load it - ```library(tidyverse)``` automatically loads this package for you.

ggplot is an attempt to extend R's basic graphics abilities to make publication-quality graphics faster and easier than ever before. In fact, we can make a version of our scatterplot above, just by typing:

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) + 
  geom_point()
```

There are four important steps that went into making that graphL

* First, the ```ggplot()``` call tells R that we want to create a ggplot object
* Second, the ``` data = iris``` tells ggplot that everything we do should use the iris dataset
* Third, the ```aes()``` specifies the _aesthetics_ of the graph - what goes on the X and Y axes, but also any other data we want represented in our plot
* Finally, the ```geom``` tells ggplot what sort of graph we want. ```geom_point``` generates a scatterplot, but there are plenty of other options to choose from.

Each of these steps can have different values, if we want to change our graph. For instance, if we wanted to color - and add a trendline for - each species of iris, we could do the following:

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
  geom_point() + 
  geom_smooth()
```

Our graph makes a lot more sense now - sepal length and width seem to be correlated, but each species is different.